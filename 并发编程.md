# 模块化

.py文件就相当于模块 

包实际上是目录。包中可以含有子包

模块类型包括.py文件和目录  统称为模块

两个原则：

1.导入包时最小原则，因为要加载到资源珍贵的内存中去，所以只加载包自身所对应的资源，因为包时目录，同时又是标识符，所以包里边常常含有一个__init__文件,用来表示该包所对应的资源。

2.有父才有子，也就是是说导入子模块时一定会导入父包。

~~~python
utils
 +-- __ini__.py 
 +-- web.py
 +-- net 
     +-- __init__.py
# 报名和模块名必须小写，函数名一般小写，类名大驼峰
# 全大写表明常量或是枚举类型 
import utils  # 只加载了utils/__init__.py的资源（也就是自身的资源）
# 导入包，就是为当前编程环境提供一个可用的标识符 utils
# 导入包，就是加载包到内存中取，该包的直接代码__init__被执行
# 导入只能导入模块类型，即包或者.py文件。模块只是组织资源的方式
import utils.net  # 导入了utils和net包，两个包都被加载了。能用的标识符只是utils.

from utils import web # 后边可导模块，类，函数，变量。总结就是标识符，不能web.X
# 先导入utils在导入web， 但是能用的标识符只有import后的web
from utils.web import X # 导入变量
# from 后边是只能是模块类型
from utils.net import C, A  # 按需导入，推荐
from utils.net import *  # 容易造成变量污染， 不推荐，但是可以配合__all__ = []使用
# *不能导入_ __/__x__开头的特殊变量。
# __all__的列表里边放的都是最重要的标识符


# 导入工作目录下的模块/py的sit-package的模块 叫绝对导入
# 相对导入只能在包内使用，前不能运行。运行时主模块
# . .. 与目录操作的意思一样代表目录层级‘只能在from中使用
# py解释器内部会加载一些模块可以在sys.moulde字典中查看。
# 模块指会加载一次也是根据这个字典来去重的
~~~

### 变量的作用域

模块中的顶层代码就是模块中的全局变量

globals()返回一个当前名词空间即当前模块的全局变量的字典

模块中的变量不能跨模块使用，除非导入模块，注意导入模块时的标识符污染问题

locals()产看局部变量，根据该语句所在的位置返回的字典也会不同。

合理使用两个方法来查看什么标识符能够使用

LEGB，只有builtin能够跨模块使用

# 并发编程

## 并行和并发

- 并行：在同一时刻做某些事，在同时刻运行互不干扰
- 并发：在某个时间段，要做某些事情，可以采用并行也可以采用串行。并行之中也可以有串行。队列操作。消息队列，消息中间件

 ## 程序和进程和线程

- 程序：常常是源程序，也就是在磁盘中的文本文件。不论是编译后或是未编译的的源文件，他们都是未加载到内存中的程序

- 进程：将程序编译为机器码加载到内存当中，进程会占一部分系统资源， 其中有数据/程序指令。。一个程序的执行实例就是一个进程。它也是线 程的容器。有id。

  在win中每个进程都是平等的

  进程就是资源管理单位

- 线程：LWP（lightweight process）轻量级进程，线程才是真正执行指令的东西。线程包括线程id，程序计数器PC(指向下一条将要执行的汇编指令)，寄存器集合，堆栈等资源

​    在许多系统中，创建一个线程比创建一个进程快10-100倍。但这并不意味着创建多线程会比多进程好。具体问题具体分析。

### 进程与线程

现代操作系统提出进程的概念，每一个进程都认为自己独占所有的计算机硬件资源。

进程相当于一个国家，而线程相当于一个省，不同线程之间能够共享进程资源，不能共享线程资源

## 线程的状态

1.ready ：创建线程，进程占资源，线程来执行代码，但是需要cpu的调度才能真正运行起来

- 线程能够运行，但在等待被调度。可能线程刚刚创建启动，或刚刚从阻塞中恢 复，或者被其他线程抢占

2.run ：从就绪的程序随机调度程序来以一个时间片的时间执行

3.blocked：程序涉及到IO等操作，比如等网络数据就会将成程序阻塞，程序也会一定保持这个状态。

- 线程等待外部事件发生而无法运行，如I/O操作

4.terminated：

单核cpu中，程序的并行是伪并行。每个时间片（微秒级）执行  同/不同程序的指令。表现出并行

![image-20210218222014961](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20210218222014961.png)

## python中的进程与线程

~~~python
# 函数定义在什么地方并不会影响线程对该函数的使用，只要满足作用域原则。
# 工作线程中也能使用顶层代码定义的函数

# python内置模块中threading.Thread类能帮助创建线程
# 主线程：运行py程序的时候，py解释器会启动一个进程，线程共享一个解释器进程。
# 而一个进程中至少得有一个线程（干活）才能运行起来，其他是工作线程
# 所以py中必须有一个主线程，这也表明了程序入口。
import threading
import time


class Mythread(threading.Thread):
    def start(self):
        print('start------')
        super().start()

    def run(self):
        print('run------')
        super().run()  # 没有返回值

def worker():
    for i in range(5):
        time.sleep(1)
        print('working~~~~~~~~', threading.current_thread().name)


# def __init__(self, group=None, target=None, name=None,
#                  args=(), kwargs=None, *, daemon=None)
t = threading.Thread(name='worker', target=worker)
# group留作备用（不用）， target目标，只要在线程中执行的函数对象。args位置传参元组，kwargs关键字传参字典
t.start()  # 创建一个工作线程，并在线程中运行函数，即在线程上运行run()方法
# 该方法会立即返回，会阻塞一下，因为要创建新线程。不返回 函数不会结束调用，会一直阻塞。返回后立即执行主线程的代码（返回值none）
# t.start() 会报错一个线程对象只能运行一次
# t.run()  # 会在当前线程（threading.current_thread()）中运行该worker函数，相当于worker().run()方法没有返回值。也不会创建线程


~~~

### python线程退出

Python没有提供线程退出的方法，线程在下面情况时退出 

1、线程函数内语句执行完毕

 2、线程函数中抛出未处理的异常

**Python的线程没有优先级、没有线程组的概念，也不能被销毁、停止、挂起，那也就没有恢复、中断了。**

### threading的属性和方法

- current_thread() 返回当前线程对象 
- main_thread() 返回主线程对象 
- active_count() 当前处于alive状态的线程个数 
- enumerate() 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程 g
- et_ident() 返回当前线程的ID，非0整数

### Thread实例的属性和方法

- name 只是一个名字，只是个标识，名称可以重名。getName()、setName()获取、设置这 个名词 
- ident 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可 以访问。此ID可以重复使用 
- is_alive() 返回线程是否活着

## 线程安全

多线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。 

多线程在运行过程中，由于共享同一进程中的数据，多线程并发使用同一个数据，那么数据就有可能被 相互修改，从而导致某些时刻无法确定这个数据的值，最终随着多线程运行，运行结果不可预期，这就 是线程不安全。

## daemon线程

构造Thread()对象时有一个关键字传参daemon。

daemon值为None，这种线程称为non-daemon线程

如果不给daemon参数，则默认取当前线程的daemon值。当前线程也就是父线程

- daemon属性 表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发 RuntimeError异常 
- isDaemon() 是否是daemon线程 
- setDaemon 设置为daemon线程，必须在start方法之前设置

### 进程退出

主线程是non-daemon线程。

进程要退出则该进程下已经没有non-daemon线程在执行。还在执行的daemon线程会被杀掉

主线程没事可做了就会挂掉，如果此时没有其他的non-daemon线程执行则进程退出。有就继续等待至所有non-daemon线程执行完毕

主线程报错是很严重的，在某一个线程内的异常没有被处理就会导致该线程崩溃，退出

### join(timeout=None)

- join(timeout=None) join方法是线程的标准方法之一 
- 一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止，或阻塞超时 
- 一个线程可以被join多次 
- timeout参数指定调用者等待多久，没有设置超时，就一直等到被调用线程结束 
- 调用谁的join方法，就是join谁，就要等谁

## daemon线程应用场景

主要应用场景有： （创建线程的时候想一下就行了）

1. 后台任务。如发送心跳包、监控，这种场景最多 

2. 主线程工作才有用的线程。如主线程中维护这公共的资源，主线程已经清理了，准备退出，而工作 线程使用这些资源工作也没有意义了，一起退出最合适 

3. 随时可以被终止的线程 如果主线程退出，想所有其它工作线程一起退出，就使用daemon=True来创建工作线程。 

   比如，开启一个线程定时判断WEB服务是否正常工作，主线程退出，工作线程也没有必须存在了，应该 随着主线程退出一起退出。这种daemon线程一旦创建，就可以忘记它了，只用关心主线程什么时候退 出就行了。 

   daemon线程，简化了程序员手动关闭线程的工作。