# 模块化

.py文件就相当于模块 

包实际上是目录。包中可以含有子包

模块类型包括.py文件和目录  统称为模块

两个原则：

1.导入包时最小原则，因为要加载到资源珍贵的内存中去，所以只加载包自身所对应的资源，因为包时目录，同时又是标识符，所以包里边常常含有一个__init__文件,用来表示该包所对应的资源。

2.有父才有子，也就是是说导入子模块时一定会导入父包。

~~~python
utils
 +-- __ini__.py 
 +-- web.py
 +-- net 
     +-- __init__.py
# 报名和模块名必须小写，函数名一般小写，类名大驼峰
# 全大写表明常量或是枚举类型 
import utils  # 只加载了utils/__init__.py的资源（也就是自身的资源）
# 导入包，就是为当前编程环境提供一个可用的标识符 utils
# 导入包，就是加载包到内存中取，该包的直接代码__init__被执行
# 导入只能导入模块类型，即包或者.py文件。模块只是组织资源的方式
import utils.net  # 导入了utils和net包，两个包都被加载了。能用的标识符只是utils.

from utils import web # 后边可导模块，类，函数，变量。总结就是标识符，不能web.X
# 先导入utils在导入web， 但是能用的标识符只有import后的web
from utils.web import X # 导入变量
# from 后边是只能是模块类型
from utils.net import C, A  # 按需导入，推荐
from utils.net import *  # 容易造成变量污染， 不推荐，但是可以配合__all__ = []使用
# *不能导入_ __/__x__开头的特殊变量。
# __all__的列表里边放的都是最重要的标识符


# 导入工作目录下的模块/py的sit-package的模块 叫绝对导入
# 相对导入只能在包内使用，前不能运行。运行时主模块
# . .. 与目录操作的意思一样代表目录层级‘只能在from中使用
# py解释器内部会加载一些模块可以在sys.moulde字典中查看。
# 模块指会加载一次也是根据这个字典来去重的
~~~

### 变量的作用域

模块中的顶层代码就是模块中的全局变量

globals()返回一个当前名词空间即当前模块的全局变量的字典

模块中的变量不能跨模块使用，除非导入模块，注意导入模块时的标识符污染问题

locals()产看局部变量，根据该语句所在的位置返回的字典也会不同。

合理使用两个方法来查看什么标识符能够使用

LEGB，只有builtin能够跨模块使用

# 并发编程

